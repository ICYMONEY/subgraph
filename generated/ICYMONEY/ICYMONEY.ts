// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.

import {
  ethereum,
  JSONValue,
  TypedMap,
  Entity,
  Bytes,
  Address,
  BigInt
} from "@graphprotocol/graph-ts";

export class Approval extends ethereum.Event {
  get params(): Approval__Params {
    return new Approval__Params(this);
  }
}

export class Approval__Params {
  _event: Approval;

  constructor(event: Approval) {
    this._event = event;
  }

  get owner(): Address {
    return this._event.parameters[0].value.toAddress();
  }

  get spender(): Address {
    return this._event.parameters[1].value.toAddress();
  }

  get value(): BigInt {
    return this._event.parameters[2].value.toBigInt();
  }
}

export class AutoLiquify extends ethereum.Event {
  get params(): AutoLiquify__Params {
    return new AutoLiquify__Params(this);
  }
}

export class AutoLiquify__Params {
  _event: AutoLiquify;

  constructor(event: AutoLiquify) {
    this._event = event;
  }

  get amountAVAX(): BigInt {
    return this._event.parameters[0].value.toBigInt();
  }

  get amountBOG(): BigInt {
    return this._event.parameters[1].value.toBigInt();
  }
}

export class OwnershipTransferred extends ethereum.Event {
  get params(): OwnershipTransferred__Params {
    return new OwnershipTransferred__Params(this);
  }
}

export class OwnershipTransferred__Params {
  _event: OwnershipTransferred;

  constructor(event: OwnershipTransferred) {
    this._event = event;
  }

  get owner(): Address {
    return this._event.parameters[0].value.toAddress();
  }
}

export class Transfer extends ethereum.Event {
  get params(): Transfer__Params {
    return new Transfer__Params(this);
  }
}

export class Transfer__Params {
  _event: Transfer;

  constructor(event: Transfer) {
    this._event = event;
  }

  get from(): Address {
    return this._event.parameters[0].value.toAddress();
  }

  get to(): Address {
    return this._event.parameters[1].value.toAddress();
  }

  get value(): BigInt {
    return this._event.parameters[2].value.toBigInt();
  }
}

export class ICYMONEY extends ethereum.SmartContract {
  static bind(address: Address): ICYMONEY {
    return new ICYMONEY("ICYMONEY", address);
  }

  WAVAX(): Address {
    let result = super.call("WAVAX", "WAVAX():(address)", []);

    return result[0].toAddress();
  }

  try_WAVAX(): ethereum.CallResult<Address> {
    let result = super.tryCall("WAVAX", "WAVAX():(address)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toAddress());
  }

  WETH(): Address {
    let result = super.call("WETH", "WETH():(address)", []);

    return result[0].toAddress();
  }

  try_WETH(): ethereum.CallResult<Address> {
    let result = super.tryCall("WETH", "WETH():(address)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toAddress());
  }

  _isFree(param0: Address): boolean {
    let result = super.call("_isFree", "_isFree(address):(bool)", [
      ethereum.Value.fromAddress(param0)
    ]);

    return result[0].toBoolean();
  }

  try__isFree(param0: Address): ethereum.CallResult<boolean> {
    let result = super.tryCall("_isFree", "_isFree(address):(bool)", [
      ethereum.Value.fromAddress(param0)
    ]);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBoolean());
  }

  _maxTxAmount(): BigInt {
    let result = super.call("_maxTxAmount", "_maxTxAmount():(uint256)", []);

    return result[0].toBigInt();
  }

  try__maxTxAmount(): ethereum.CallResult<BigInt> {
    let result = super.tryCall("_maxTxAmount", "_maxTxAmount():(uint256)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  _maxWallet(): BigInt {
    let result = super.call("_maxWallet", "_maxWallet():(uint256)", []);

    return result[0].toBigInt();
  }

  try__maxWallet(): ethereum.CallResult<BigInt> {
    let result = super.tryCall("_maxWallet", "_maxWallet():(uint256)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  _totalSupply(): BigInt {
    let result = super.call("_totalSupply", "_totalSupply():(uint256)", []);

    return result[0].toBigInt();
  }

  try__totalSupply(): ethereum.CallResult<BigInt> {
    let result = super.tryCall("_totalSupply", "_totalSupply():(uint256)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  allowance(holder: Address, spender: Address): BigInt {
    let result = super.call(
      "allowance",
      "allowance(address,address):(uint256)",
      [ethereum.Value.fromAddress(holder), ethereum.Value.fromAddress(spender)]
    );

    return result[0].toBigInt();
  }

  try_allowance(
    holder: Address,
    spender: Address
  ): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "allowance",
      "allowance(address,address):(uint256)",
      [ethereum.Value.fromAddress(holder), ethereum.Value.fromAddress(spender)]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  approve(spender: Address, amount: BigInt): boolean {
    let result = super.call("approve", "approve(address,uint256):(bool)", [
      ethereum.Value.fromAddress(spender),
      ethereum.Value.fromUnsignedBigInt(amount)
    ]);

    return result[0].toBoolean();
  }

  try_approve(spender: Address, amount: BigInt): ethereum.CallResult<boolean> {
    let result = super.tryCall("approve", "approve(address,uint256):(bool)", [
      ethereum.Value.fromAddress(spender),
      ethereum.Value.fromUnsignedBigInt(amount)
    ]);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBoolean());
  }

  approveMax(spender: Address): boolean {
    let result = super.call("approveMax", "approveMax(address):(bool)", [
      ethereum.Value.fromAddress(spender)
    ]);

    return result[0].toBoolean();
  }

  try_approveMax(spender: Address): ethereum.CallResult<boolean> {
    let result = super.tryCall("approveMax", "approveMax(address):(bool)", [
      ethereum.Value.fromAddress(spender)
    ]);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBoolean());
  }

  balanceOf(account: Address): BigInt {
    let result = super.call("balanceOf", "balanceOf(address):(uint256)", [
      ethereum.Value.fromAddress(account)
    ]);

    return result[0].toBigInt();
  }

  try_balanceOf(account: Address): ethereum.CallResult<BigInt> {
    let result = super.tryCall("balanceOf", "balanceOf(address):(uint256)", [
      ethereum.Value.fromAddress(account)
    ]);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  checkFree(holder: Address): boolean {
    let result = super.call("checkFree", "checkFree(address):(bool)", [
      ethereum.Value.fromAddress(holder)
    ]);

    return result[0].toBoolean();
  }

  try_checkFree(holder: Address): ethereum.CallResult<boolean> {
    let result = super.tryCall("checkFree", "checkFree(address):(bool)", [
      ethereum.Value.fromAddress(holder)
    ]);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBoolean());
  }

  decimals(): i32 {
    let result = super.call("decimals", "decimals():(uint8)", []);

    return result[0].toI32();
  }

  try_decimals(): ethereum.CallResult<i32> {
    let result = super.tryCall("decimals", "decimals():(uint8)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toI32());
  }

  distributorAddress(): Address {
    let result = super.call(
      "distributorAddress",
      "distributorAddress():(address)",
      []
    );

    return result[0].toAddress();
  }

  try_distributorAddress(): ethereum.CallResult<Address> {
    let result = super.tryCall(
      "distributorAddress",
      "distributorAddress():(address)",
      []
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toAddress());
  }

  getCirculatingSupply(): BigInt {
    let result = super.call(
      "getCirculatingSupply",
      "getCirculatingSupply():(uint256)",
      []
    );

    return result[0].toBigInt();
  }

  try_getCirculatingSupply(): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "getCirculatingSupply",
      "getCirculatingSupply():(uint256)",
      []
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  getLiquidityBacking(accuracy: BigInt): BigInt {
    let result = super.call(
      "getLiquidityBacking",
      "getLiquidityBacking(uint256):(uint256)",
      [ethereum.Value.fromUnsignedBigInt(accuracy)]
    );

    return result[0].toBigInt();
  }

  try_getLiquidityBacking(accuracy: BigInt): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "getLiquidityBacking",
      "getLiquidityBacking(uint256):(uint256)",
      [ethereum.Value.fromUnsignedBigInt(accuracy)]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  getMultipliedFee(): BigInt {
    let result = super.call(
      "getMultipliedFee",
      "getMultipliedFee():(uint256)",
      []
    );

    return result[0].toBigInt();
  }

  try_getMultipliedFee(): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "getMultipliedFee",
      "getMultipliedFee():(uint256)",
      []
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  getOwner(): Address {
    let result = super.call("getOwner", "getOwner():(address)", []);

    return result[0].toAddress();
  }

  try_getOwner(): ethereum.CallResult<Address> {
    let result = super.tryCall("getOwner", "getOwner():(address)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toAddress());
  }

  getTotalFee(selling: boolean): BigInt {
    let result = super.call("getTotalFee", "getTotalFee(bool):(uint256)", [
      ethereum.Value.fromBoolean(selling)
    ]);

    return result[0].toBigInt();
  }

  try_getTotalFee(selling: boolean): ethereum.CallResult<BigInt> {
    let result = super.tryCall("getTotalFee", "getTotalFee(bool):(uint256)", [
      ethereum.Value.fromBoolean(selling)
    ]);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  isAuthorized(adr: Address): boolean {
    let result = super.call("isAuthorized", "isAuthorized(address):(bool)", [
      ethereum.Value.fromAddress(adr)
    ]);

    return result[0].toBoolean();
  }

  try_isAuthorized(adr: Address): ethereum.CallResult<boolean> {
    let result = super.tryCall("isAuthorized", "isAuthorized(address):(bool)", [
      ethereum.Value.fromAddress(adr)
    ]);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBoolean());
  }

  isOverLiquified(target: BigInt, accuracy: BigInt): boolean {
    let result = super.call(
      "isOverLiquified",
      "isOverLiquified(uint256,uint256):(bool)",
      [
        ethereum.Value.fromUnsignedBigInt(target),
        ethereum.Value.fromUnsignedBigInt(accuracy)
      ]
    );

    return result[0].toBoolean();
  }

  try_isOverLiquified(
    target: BigInt,
    accuracy: BigInt
  ): ethereum.CallResult<boolean> {
    let result = super.tryCall(
      "isOverLiquified",
      "isOverLiquified(uint256,uint256):(bool)",
      [
        ethereum.Value.fromUnsignedBigInt(target),
        ethereum.Value.fromUnsignedBigInt(accuracy)
      ]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBoolean());
  }

  isOwner(account: Address): boolean {
    let result = super.call("isOwner", "isOwner(address):(bool)", [
      ethereum.Value.fromAddress(account)
    ]);

    return result[0].toBoolean();
  }

  try_isOwner(account: Address): ethereum.CallResult<boolean> {
    let result = super.tryCall("isOwner", "isOwner(address):(bool)", [
      ethereum.Value.fromAddress(account)
    ]);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBoolean());
  }

  launchedAt(): BigInt {
    let result = super.call("launchedAt", "launchedAt():(uint256)", []);

    return result[0].toBigInt();
  }

  try_launchedAt(): ethereum.CallResult<BigInt> {
    let result = super.tryCall("launchedAt", "launchedAt():(uint256)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  launchedAtTimestamp(): BigInt {
    let result = super.call(
      "launchedAtTimestamp",
      "launchedAtTimestamp():(uint256)",
      []
    );

    return result[0].toBigInt();
  }

  try_launchedAtTimestamp(): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "launchedAtTimestamp",
      "launchedAtTimestamp():(uint256)",
      []
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  liquidityWallet(): Address {
    let result = super.call(
      "liquidityWallet",
      "liquidityWallet():(address)",
      []
    );

    return result[0].toAddress();
  }

  try_liquidityWallet(): ethereum.CallResult<Address> {
    let result = super.tryCall(
      "liquidityWallet",
      "liquidityWallet():(address)",
      []
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toAddress());
  }

  marketingWallet(): Address {
    let result = super.call(
      "marketingWallet",
      "marketingWallet():(address)",
      []
    );

    return result[0].toAddress();
  }

  try_marketingWallet(): ethereum.CallResult<Address> {
    let result = super.tryCall(
      "marketingWallet",
      "marketingWallet():(address)",
      []
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toAddress());
  }

  name(): string {
    let result = super.call("name", "name():(string)", []);

    return result[0].toString();
  }

  try_name(): ethereum.CallResult<string> {
    let result = super.tryCall("name", "name():(string)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toString());
  }

  pair(): Address {
    let result = super.call("pair", "pair():(address)", []);

    return result[0].toAddress();
  }

  try_pair(): ethereum.CallResult<Address> {
    let result = super.tryCall("pair", "pair():(address)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toAddress());
  }

  router(): Address {
    let result = super.call("router", "router():(address)", []);

    return result[0].toAddress();
  }

  try_router(): ethereum.CallResult<Address> {
    let result = super.tryCall("router", "router():(address)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toAddress());
  }

  routerAddress(): Address {
    let result = super.call("routerAddress", "routerAddress():(address)", []);

    return result[0].toAddress();
  }

  try_routerAddress(): ethereum.CallResult<Address> {
    let result = super.tryCall(
      "routerAddress",
      "routerAddress():(address)",
      []
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toAddress());
  }

  swapEnabled(): boolean {
    let result = super.call("swapEnabled", "swapEnabled():(bool)", []);

    return result[0].toBoolean();
  }

  try_swapEnabled(): ethereum.CallResult<boolean> {
    let result = super.tryCall("swapEnabled", "swapEnabled():(bool)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBoolean());
  }

  swapThreshold(): BigInt {
    let result = super.call("swapThreshold", "swapThreshold():(uint256)", []);

    return result[0].toBigInt();
  }

  try_swapThreshold(): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "swapThreshold",
      "swapThreshold():(uint256)",
      []
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  symbol(): string {
    let result = super.call("symbol", "symbol():(string)", []);

    return result[0].toString();
  }

  try_symbol(): ethereum.CallResult<string> {
    let result = super.tryCall("symbol", "symbol():(string)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toString());
  }

  totalSupply(): BigInt {
    let result = super.call("totalSupply", "totalSupply():(uint256)", []);

    return result[0].toBigInt();
  }

  try_totalSupply(): ethereum.CallResult<BigInt> {
    let result = super.tryCall("totalSupply", "totalSupply():(uint256)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  transfer(recipient: Address, amount: BigInt): boolean {
    let result = super.call("transfer", "transfer(address,uint256):(bool)", [
      ethereum.Value.fromAddress(recipient),
      ethereum.Value.fromUnsignedBigInt(amount)
    ]);

    return result[0].toBoolean();
  }

  try_transfer(
    recipient: Address,
    amount: BigInt
  ): ethereum.CallResult<boolean> {
    let result = super.tryCall("transfer", "transfer(address,uint256):(bool)", [
      ethereum.Value.fromAddress(recipient),
      ethereum.Value.fromUnsignedBigInt(amount)
    ]);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBoolean());
  }

  transferFrom(sender: Address, recipient: Address, amount: BigInt): boolean {
    let result = super.call(
      "transferFrom",
      "transferFrom(address,address,uint256):(bool)",
      [
        ethereum.Value.fromAddress(sender),
        ethereum.Value.fromAddress(recipient),
        ethereum.Value.fromUnsignedBigInt(amount)
      ]
    );

    return result[0].toBoolean();
  }

  try_transferFrom(
    sender: Address,
    recipient: Address,
    amount: BigInt
  ): ethereum.CallResult<boolean> {
    let result = super.tryCall(
      "transferFrom",
      "transferFrom(address,address,uint256):(bool)",
      [
        ethereum.Value.fromAddress(sender),
        ethereum.Value.fromAddress(recipient),
        ethereum.Value.fromUnsignedBigInt(amount)
      ]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBoolean());
  }

  treasuryWallet(): Address {
    let result = super.call("treasuryWallet", "treasuryWallet():(address)", []);

    return result[0].toAddress();
  }

  try_treasuryWallet(): ethereum.CallResult<Address> {
    let result = super.tryCall(
      "treasuryWallet",
      "treasuryWallet():(address)",
      []
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toAddress());
  }
}

export class ConstructorCall extends ethereum.Call {
  get inputs(): ConstructorCall__Inputs {
    return new ConstructorCall__Inputs(this);
  }

  get outputs(): ConstructorCall__Outputs {
    return new ConstructorCall__Outputs(this);
  }
}

export class ConstructorCall__Inputs {
  _call: ConstructorCall;

  constructor(call: ConstructorCall) {
    this._call = call;
  }
}

export class ConstructorCall__Outputs {
  _call: ConstructorCall;

  constructor(call: ConstructorCall) {
    this._call = call;
  }
}

export class SweepCall extends ethereum.Call {
  get inputs(): SweepCall__Inputs {
    return new SweepCall__Inputs(this);
  }

  get outputs(): SweepCall__Outputs {
    return new SweepCall__Outputs(this);
  }
}

export class SweepCall__Inputs {
  _call: SweepCall;

  constructor(call: SweepCall) {
    this._call = call;
  }
}

export class SweepCall__Outputs {
  _call: SweepCall;

  constructor(call: SweepCall) {
    this._call = call;
  }
}

export class ApproveCall extends ethereum.Call {
  get inputs(): ApproveCall__Inputs {
    return new ApproveCall__Inputs(this);
  }

  get outputs(): ApproveCall__Outputs {
    return new ApproveCall__Outputs(this);
  }
}

export class ApproveCall__Inputs {
  _call: ApproveCall;

  constructor(call: ApproveCall) {
    this._call = call;
  }

  get spender(): Address {
    return this._call.inputValues[0].value.toAddress();
  }

  get amount(): BigInt {
    return this._call.inputValues[1].value.toBigInt();
  }
}

export class ApproveCall__Outputs {
  _call: ApproveCall;

  constructor(call: ApproveCall) {
    this._call = call;
  }

  get value0(): boolean {
    return this._call.outputValues[0].value.toBoolean();
  }
}

export class ApproveMaxCall extends ethereum.Call {
  get inputs(): ApproveMaxCall__Inputs {
    return new ApproveMaxCall__Inputs(this);
  }

  get outputs(): ApproveMaxCall__Outputs {
    return new ApproveMaxCall__Outputs(this);
  }
}

export class ApproveMaxCall__Inputs {
  _call: ApproveMaxCall;

  constructor(call: ApproveMaxCall) {
    this._call = call;
  }

  get spender(): Address {
    return this._call.inputValues[0].value.toAddress();
  }
}

export class ApproveMaxCall__Outputs {
  _call: ApproveMaxCall;

  constructor(call: ApproveMaxCall) {
    this._call = call;
  }

  get value0(): boolean {
    return this._call.outputValues[0].value.toBoolean();
  }
}

export class AuthorizeCall extends ethereum.Call {
  get inputs(): AuthorizeCall__Inputs {
    return new AuthorizeCall__Inputs(this);
  }

  get outputs(): AuthorizeCall__Outputs {
    return new AuthorizeCall__Outputs(this);
  }
}

export class AuthorizeCall__Inputs {
  _call: AuthorizeCall;

  constructor(call: AuthorizeCall) {
    this._call = call;
  }

  get adr(): Address {
    return this._call.inputValues[0].value.toAddress();
  }
}

export class AuthorizeCall__Outputs {
  _call: AuthorizeCall;

  constructor(call: AuthorizeCall) {
    this._call = call;
  }
}

export class LaunchCall extends ethereum.Call {
  get inputs(): LaunchCall__Inputs {
    return new LaunchCall__Inputs(this);
  }

  get outputs(): LaunchCall__Outputs {
    return new LaunchCall__Outputs(this);
  }
}

export class LaunchCall__Inputs {
  _call: LaunchCall;

  constructor(call: LaunchCall) {
    this._call = call;
  }
}

export class LaunchCall__Outputs {
  _call: LaunchCall;

  constructor(call: LaunchCall) {
    this._call = call;
  }
}

export class SetDistributionCriteriaCall extends ethereum.Call {
  get inputs(): SetDistributionCriteriaCall__Inputs {
    return new SetDistributionCriteriaCall__Inputs(this);
  }

  get outputs(): SetDistributionCriteriaCall__Outputs {
    return new SetDistributionCriteriaCall__Outputs(this);
  }
}

export class SetDistributionCriteriaCall__Inputs {
  _call: SetDistributionCriteriaCall;

  constructor(call: SetDistributionCriteriaCall) {
    this._call = call;
  }

  get _minPeriod(): BigInt {
    return this._call.inputValues[0].value.toBigInt();
  }

  get _minDistribution(): BigInt {
    return this._call.inputValues[1].value.toBigInt();
  }
}

export class SetDistributionCriteriaCall__Outputs {
  _call: SetDistributionCriteriaCall;

  constructor(call: SetDistributionCriteriaCall) {
    this._call = call;
  }
}

export class SetDistributorSettingsCall extends ethereum.Call {
  get inputs(): SetDistributorSettingsCall__Inputs {
    return new SetDistributorSettingsCall__Inputs(this);
  }

  get outputs(): SetDistributorSettingsCall__Outputs {
    return new SetDistributorSettingsCall__Outputs(this);
  }
}

export class SetDistributorSettingsCall__Inputs {
  _call: SetDistributorSettingsCall;

  constructor(call: SetDistributorSettingsCall) {
    this._call = call;
  }

  get gas(): BigInt {
    return this._call.inputValues[0].value.toBigInt();
  }
}

export class SetDistributorSettingsCall__Outputs {
  _call: SetDistributorSettingsCall;

  constructor(call: SetDistributorSettingsCall) {
    this._call = call;
  }
}

export class SetFeesCall extends ethereum.Call {
  get inputs(): SetFeesCall__Inputs {
    return new SetFeesCall__Inputs(this);
  }

  get outputs(): SetFeesCall__Outputs {
    return new SetFeesCall__Outputs(this);
  }
}

export class SetFeesCall__Inputs {
  _call: SetFeesCall;

  constructor(call: SetFeesCall) {
    this._call = call;
  }

  get _liquidityFee(): BigInt {
    return this._call.inputValues[0].value.toBigInt();
  }

  get _treasuryFee(): BigInt {
    return this._call.inputValues[1].value.toBigInt();
  }

  get _reflectionFee(): BigInt {
    return this._call.inputValues[2].value.toBigInt();
  }

  get _marketingFee(): BigInt {
    return this._call.inputValues[3].value.toBigInt();
  }

  get _feeDenominator(): BigInt {
    return this._call.inputValues[4].value.toBigInt();
  }
}

export class SetFeesCall__Outputs {
  _call: SetFeesCall;

  constructor(call: SetFeesCall) {
    this._call = call;
  }
}

export class SetFreeCall extends ethereum.Call {
  get inputs(): SetFreeCall__Inputs {
    return new SetFreeCall__Inputs(this);
  }

  get outputs(): SetFreeCall__Outputs {
    return new SetFreeCall__Outputs(this);
  }
}

export class SetFreeCall__Inputs {
  _call: SetFreeCall;

  constructor(call: SetFreeCall) {
    this._call = call;
  }

  get holder(): Address {
    return this._call.inputValues[0].value.toAddress();
  }
}

export class SetFreeCall__Outputs {
  _call: SetFreeCall;

  constructor(call: SetFreeCall) {
    this._call = call;
  }
}

export class SetIsDividendExemptCall extends ethereum.Call {
  get inputs(): SetIsDividendExemptCall__Inputs {
    return new SetIsDividendExemptCall__Inputs(this);
  }

  get outputs(): SetIsDividendExemptCall__Outputs {
    return new SetIsDividendExemptCall__Outputs(this);
  }
}

export class SetIsDividendExemptCall__Inputs {
  _call: SetIsDividendExemptCall;

  constructor(call: SetIsDividendExemptCall) {
    this._call = call;
  }

  get holder(): Address {
    return this._call.inputValues[0].value.toAddress();
  }

  get exempt(): boolean {
    return this._call.inputValues[1].value.toBoolean();
  }
}

export class SetIsDividendExemptCall__Outputs {
  _call: SetIsDividendExemptCall;

  constructor(call: SetIsDividendExemptCall) {
    this._call = call;
  }
}

export class SetIsFeeExemptCall extends ethereum.Call {
  get inputs(): SetIsFeeExemptCall__Inputs {
    return new SetIsFeeExemptCall__Inputs(this);
  }

  get outputs(): SetIsFeeExemptCall__Outputs {
    return new SetIsFeeExemptCall__Outputs(this);
  }
}

export class SetIsFeeExemptCall__Inputs {
  _call: SetIsFeeExemptCall;

  constructor(call: SetIsFeeExemptCall) {
    this._call = call;
  }

  get holder(): Address {
    return this._call.inputValues[0].value.toAddress();
  }

  get exempt(): boolean {
    return this._call.inputValues[1].value.toBoolean();
  }
}

export class SetIsFeeExemptCall__Outputs {
  _call: SetIsFeeExemptCall;

  constructor(call: SetIsFeeExemptCall) {
    this._call = call;
  }
}

export class SetIsTxLimitExemptCall extends ethereum.Call {
  get inputs(): SetIsTxLimitExemptCall__Inputs {
    return new SetIsTxLimitExemptCall__Inputs(this);
  }

  get outputs(): SetIsTxLimitExemptCall__Outputs {
    return new SetIsTxLimitExemptCall__Outputs(this);
  }
}

export class SetIsTxLimitExemptCall__Inputs {
  _call: SetIsTxLimitExemptCall;

  constructor(call: SetIsTxLimitExemptCall) {
    this._call = call;
  }

  get holder(): Address {
    return this._call.inputValues[0].value.toAddress();
  }

  get exempt(): boolean {
    return this._call.inputValues[1].value.toBoolean();
  }
}

export class SetIsTxLimitExemptCall__Outputs {
  _call: SetIsTxLimitExemptCall;

  constructor(call: SetIsTxLimitExemptCall) {
    this._call = call;
  }
}

export class SetMaxWalletCall extends ethereum.Call {
  get inputs(): SetMaxWalletCall__Inputs {
    return new SetMaxWalletCall__Inputs(this);
  }

  get outputs(): SetMaxWalletCall__Outputs {
    return new SetMaxWalletCall__Outputs(this);
  }
}

export class SetMaxWalletCall__Inputs {
  _call: SetMaxWalletCall;

  constructor(call: SetMaxWalletCall) {
    this._call = call;
  }

  get amount(): BigInt {
    return this._call.inputValues[0].value.toBigInt();
  }
}

export class SetMaxWalletCall__Outputs {
  _call: SetMaxWalletCall;

  constructor(call: SetMaxWalletCall) {
    this._call = call;
  }
}

export class SetSwapBackSettingsCall extends ethereum.Call {
  get inputs(): SetSwapBackSettingsCall__Inputs {
    return new SetSwapBackSettingsCall__Inputs(this);
  }

  get outputs(): SetSwapBackSettingsCall__Outputs {
    return new SetSwapBackSettingsCall__Outputs(this);
  }
}

export class SetSwapBackSettingsCall__Inputs {
  _call: SetSwapBackSettingsCall;

  constructor(call: SetSwapBackSettingsCall) {
    this._call = call;
  }

  get _enabled(): boolean {
    return this._call.inputValues[0].value.toBoolean();
  }

  get _amount(): BigInt {
    return this._call.inputValues[1].value.toBigInt();
  }
}

export class SetSwapBackSettingsCall__Outputs {
  _call: SetSwapBackSettingsCall;

  constructor(call: SetSwapBackSettingsCall) {
    this._call = call;
  }
}

export class SetTargetLiquidityCall extends ethereum.Call {
  get inputs(): SetTargetLiquidityCall__Inputs {
    return new SetTargetLiquidityCall__Inputs(this);
  }

  get outputs(): SetTargetLiquidityCall__Outputs {
    return new SetTargetLiquidityCall__Outputs(this);
  }
}

export class SetTargetLiquidityCall__Inputs {
  _call: SetTargetLiquidityCall;

  constructor(call: SetTargetLiquidityCall) {
    this._call = call;
  }

  get _target(): BigInt {
    return this._call.inputValues[0].value.toBigInt();
  }

  get _denominator(): BigInt {
    return this._call.inputValues[1].value.toBigInt();
  }
}

export class SetTargetLiquidityCall__Outputs {
  _call: SetTargetLiquidityCall;

  constructor(call: SetTargetLiquidityCall) {
    this._call = call;
  }
}

export class SetTxLimitCall extends ethereum.Call {
  get inputs(): SetTxLimitCall__Inputs {
    return new SetTxLimitCall__Inputs(this);
  }

  get outputs(): SetTxLimitCall__Outputs {
    return new SetTxLimitCall__Outputs(this);
  }
}

export class SetTxLimitCall__Inputs {
  _call: SetTxLimitCall;

  constructor(call: SetTxLimitCall) {
    this._call = call;
  }

  get amount(): BigInt {
    return this._call.inputValues[0].value.toBigInt();
  }
}

export class SetTxLimitCall__Outputs {
  _call: SetTxLimitCall;

  constructor(call: SetTxLimitCall) {
    this._call = call;
  }
}

export class SetWalletsCall extends ethereum.Call {
  get inputs(): SetWalletsCall__Inputs {
    return new SetWalletsCall__Inputs(this);
  }

  get outputs(): SetWalletsCall__Outputs {
    return new SetWalletsCall__Outputs(this);
  }
}

export class SetWalletsCall__Inputs {
  _call: SetWalletsCall;

  constructor(call: SetWalletsCall) {
    this._call = call;
  }

  get _liquidityWallet(): Address {
    return this._call.inputValues[0].value.toAddress();
  }

  get _treasuryWallet(): Address {
    return this._call.inputValues[1].value.toAddress();
  }

  get _marketingWallet(): Address {
    return this._call.inputValues[2].value.toAddress();
  }
}

export class SetWalletsCall__Outputs {
  _call: SetWalletsCall;

  constructor(call: SetWalletsCall) {
    this._call = call;
  }
}

export class TransferCall extends ethereum.Call {
  get inputs(): TransferCall__Inputs {
    return new TransferCall__Inputs(this);
  }

  get outputs(): TransferCall__Outputs {
    return new TransferCall__Outputs(this);
  }
}

export class TransferCall__Inputs {
  _call: TransferCall;

  constructor(call: TransferCall) {
    this._call = call;
  }

  get recipient(): Address {
    return this._call.inputValues[0].value.toAddress();
  }

  get amount(): BigInt {
    return this._call.inputValues[1].value.toBigInt();
  }
}

export class TransferCall__Outputs {
  _call: TransferCall;

  constructor(call: TransferCall) {
    this._call = call;
  }

  get value0(): boolean {
    return this._call.outputValues[0].value.toBoolean();
  }
}

export class TransferFromCall extends ethereum.Call {
  get inputs(): TransferFromCall__Inputs {
    return new TransferFromCall__Inputs(this);
  }

  get outputs(): TransferFromCall__Outputs {
    return new TransferFromCall__Outputs(this);
  }
}

export class TransferFromCall__Inputs {
  _call: TransferFromCall;

  constructor(call: TransferFromCall) {
    this._call = call;
  }

  get sender(): Address {
    return this._call.inputValues[0].value.toAddress();
  }

  get recipient(): Address {
    return this._call.inputValues[1].value.toAddress();
  }

  get amount(): BigInt {
    return this._call.inputValues[2].value.toBigInt();
  }
}

export class TransferFromCall__Outputs {
  _call: TransferFromCall;

  constructor(call: TransferFromCall) {
    this._call = call;
  }

  get value0(): boolean {
    return this._call.outputValues[0].value.toBoolean();
  }
}

export class TransferOwnershipCall extends ethereum.Call {
  get inputs(): TransferOwnershipCall__Inputs {
    return new TransferOwnershipCall__Inputs(this);
  }

  get outputs(): TransferOwnershipCall__Outputs {
    return new TransferOwnershipCall__Outputs(this);
  }
}

export class TransferOwnershipCall__Inputs {
  _call: TransferOwnershipCall;

  constructor(call: TransferOwnershipCall) {
    this._call = call;
  }

  get adr(): Address {
    return this._call.inputValues[0].value.toAddress();
  }
}

export class TransferOwnershipCall__Outputs {
  _call: TransferOwnershipCall;

  constructor(call: TransferOwnershipCall) {
    this._call = call;
  }
}

export class UnSetFreeCall extends ethereum.Call {
  get inputs(): UnSetFreeCall__Inputs {
    return new UnSetFreeCall__Inputs(this);
  }

  get outputs(): UnSetFreeCall__Outputs {
    return new UnSetFreeCall__Outputs(this);
  }
}

export class UnSetFreeCall__Inputs {
  _call: UnSetFreeCall;

  constructor(call: UnSetFreeCall) {
    this._call = call;
  }

  get holder(): Address {
    return this._call.inputValues[0].value.toAddress();
  }
}

export class UnSetFreeCall__Outputs {
  _call: UnSetFreeCall;

  constructor(call: UnSetFreeCall) {
    this._call = call;
  }
}

export class UnauthorizeCall extends ethereum.Call {
  get inputs(): UnauthorizeCall__Inputs {
    return new UnauthorizeCall__Inputs(this);
  }

  get outputs(): UnauthorizeCall__Outputs {
    return new UnauthorizeCall__Outputs(this);
  }
}

export class UnauthorizeCall__Inputs {
  _call: UnauthorizeCall;

  constructor(call: UnauthorizeCall) {
    this._call = call;
  }

  get adr(): Address {
    return this._call.inputValues[0].value.toAddress();
  }
}

export class UnauthorizeCall__Outputs {
  _call: UnauthorizeCall;

  constructor(call: UnauthorizeCall) {
    this._call = call;
  }
}
